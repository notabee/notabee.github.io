<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON SURGE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:wght@400;700&display=swap');

        :root {
            --neon-blue: #00f3ff;
            --neon-purple: #bc13fe;
            --danger: #ff0055;
            --bg: #030305;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            font-family: 'Courier Prime', monospace;
            overflow: hidden;
            touch-action: none;
            user-select: none;
            cursor: pointer;
        }

        #game-canvas { display: block; width: 100%; height: 100vh; }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex; flex-direction: column; align-items: center;
        }

        /* Energy Bar Styling */
        #energy-container {
            position: absolute;
            top: 20px; width: 60%; height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--neon-blue);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.2);
            z-index: 10;
        }
        #energy-bar {
            width: 100%; height: 100%;
            background: var(--neon-blue);
            transition: width 0.1s linear;
        }

        .stats-top {
            position: absolute;
            top: 40px; width: 90%;
            display: flex; justify-content: space-between;
            color: var(--neon-blue); font-size: 0.8rem;
            z-index: 10;
        }

        #score-big {
            position: absolute;
            top: 15%; font-size: 5rem;
            color: rgba(255, 255, 255, 0.05);
            font-weight: bold;
            z-index: 0;
        }

        .screen {
            background: rgba(3, 3, 5, 0.95);
            padding: 40px; border: 1px solid var(--neon-blue);
            text-align: center; pointer-events: auto;
            backdrop-filter: blur(10px);
            display: flex; flex-direction: column; gap: 15px;
            margin-top: 25vh;
            z-index: 20;
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.1);
        }

        h1 { color: var(--neon-blue); text-transform: uppercase; letter-spacing: 5px; margin: 0; }
        .hidden { display: none !important; }
        
        button {
            background: transparent; color: var(--neon-blue);
            border: 1px solid var(--neon-blue); padding: 15px 30px;
            font-family: inherit; cursor: pointer; text-transform: uppercase;
            font-weight: bold;
        }
        button:hover { background: var(--neon-blue); color: #000; box-shadow: 0 0 20px var(--neon-blue); }

        #combo-alert {
            position: absolute; bottom: 20%; color: var(--neon-purple);
            font-weight: bold; font-size: 1.5rem; opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 0 10px var(--neon-purple);
            z-index: 10;
        }
    </style>
</head>
<body>

    <canvas id="game-canvas"></canvas>
    
    <div id="ui-layer">
        <div id="energy-container"><div id="energy-bar"></div></div>
        <div class="stats-top">
            <div>GRID POWER: <span id="current-score">0</span></div>
            <div>STABILITY: <span id="stability-percent">100</span>%</div>
        </div>

        <div id="score-big">0</div>
        <div id="combo-alert">LONG LINK +50%</div>

        <div id="start-screen" class="screen">
            <h1>Neon Surge</h1>
            <p style="color: #e0e0e0">Link nodes to power the grid.</p>
            <p style="color: var(--neon-purple); font-size: 0.8rem;">ENERGY DRAINS CONSTANTLY.<br>DONT STAY ON ONE NODE TOO LONG.</p>
            <button id="start-btn">Initialize Grid</button>
        </div>

        <div id="game-over-screen" class="screen hidden">
            <h1 style="color: var(--danger)">GRID COLLAPSE</h1>
            <p style="color: #fff">Total Power Generated: <span id="final-score">0</span></p>
            <button id="restart-btn">Re-Initialize</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    // --- Config ---
    const COLORS = { blue: '#00f3ff', purple: '#bc13fe', pink: '#ff0055', bg: '#030305' };
    const G = {
        rotSpeed: 0.08,      // Speed of spin
        flySpeed: 18,        // Speed of flight
        energyDrain: 0.15,   // Energy loss per frame
        nodeOverloadRate: 0.008, // How fast stability drops
        catchRadius: 35      // Hitbox size
    };

    let width, height, score, energy, nodes, lines, camera, player, gameState, requestID;

    // --- Audio System ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    function beep(freq, type, duration) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type; 
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
        osc.connect(gain); 
        gain.connect(audioCtx.destination);
        osc.start(); 
        osc.stop(audioCtx.currentTime + duration);
    }

    // --- Classes ---
    class Node {
        constructor(x, y) {
            this.x = x; 
            this.y = y;
            this.stability = 1.0; 
            this.connected = false;
            this.pulse = Math.random() * Math.PI;
        }
        draw() {
            this.pulse += 0.1;
            const screenX = this.x - camera.x;
            const screenY = this.y - camera.y;
            
            // Draw Danger Zone (Overload Indicator)
            if (player.targetNode === this && player.state === 'ORBIT') {
                const shake = (1 - this.stability) * 3;
                const sx = screenX + (Math.random() - 0.5) * shake;
                const sy = screenY + (Math.random() - 0.5) * shake;

                ctx.beginPath();
                ctx.arc(sx, sy, 45, 0, Math.PI*2);
                ctx.strokeStyle = `rgba(255, 0, 85, ${1 - this.stability})`;
                ctx.setLineDash([5, 5]);
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Outer Catch Ring
            if (!this.connected && player.state === 'FLIGHT') {
                 ctx.beginPath();
                 ctx.arc(screenX, screenY, G.catchRadius, 0, Math.PI*2);
                 ctx.strokeStyle = 'rgba(0, 243, 255, 0.1)';
                 ctx.stroke();
            }

            // Node Body
            ctx.beginPath();
            ctx.arc(screenX, screenY, 12, 0, Math.PI*2);
            ctx.fillStyle = this.connected ? COLORS.blue : '#111';
            ctx.fill();
            ctx.strokeStyle = this.stability < 0.4 ? COLORS.pink : COLORS.blue;
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Glow
            if (this.connected) {
                const glow = 10 + Math.sin(this.pulse) * 5;
                ctx.shadowBlur = glow; ctx.shadowColor = COLORS.blue;
                ctx.stroke(); ctx.shadowBlur = 0;
            }
        }
    }

    // --- Game Logic ---
    function resize() {
        width = canvas.width = window.innerWidth;
        height = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    function init() {
        if(requestID) cancelAnimationFrame(requestID);
        
        score = 0; 
        energy = 100; 
        nodes = []; 
        lines = []; 
        camera = { x: 0, y: 0 };
        gameState = 'PLAYING';

        // Setup first nodes
        const startNode = new Node(width/2, height/2 + 200);
        startNode.connected = true;
        nodes.push(startNode);
        
        player = {
            x: 0, y: 0, 
            state: 'ORBIT', 
            targetNode: startNode, 
            angle: -Math.PI/2, 
            dir: 1,
            vx: 0, vy: 0
        };

        spawnNode(); 
        spawnNode();
        spawnNode();
        
        // UI Reset
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        document.getElementById('score-big').innerText = "0";
        document.getElementById('current-score').innerText = "0";
        document.getElementById('energy-bar').style.width = '100%';
        
        // Start Loop
        loop();
    }

    function spawnNode() {
        const last = nodes[nodes.length - 1];
        // Generate upward mostly (-PI/2)
        const angle = -Math.PI/2 + (Math.random()-0.5) * 1.8;
        const dist = 220 + Math.random() * 100;
        
        // Clamp X to keep play area vaguely centered
        let tx = last.x + Math.cos(angle)*dist;
        let ty = last.y + Math.sin(angle)*dist;
        
        nodes.push(new Node(tx, ty));
        
        // Cleanup old nodes
        if(nodes.length > 8) {
             nodes.shift();
             if(lines.length > 8) lines.shift();
        }
    }

    function handleInput(e) {
        if (e) e.stopPropagation();
        
        if (gameState !== 'PLAYING') return;

        if (player.state === 'ORBIT') {
            // Calculate Release Vector (Tangent)
            const tangent = player.angle + (player.dir * Math.PI/2);
            player.vx = Math.cos(tangent) * G.flySpeed;
            player.vy = Math.sin(tangent) * G.flySpeed;
            
            player.state = 'FLIGHT';
            player.targetNode = null; // Detach
            
            beep(400, 'triangle', 0.1);
        }
    }

    function gameOver() {
        if (gameState === 'GAMEOVER') return;
        gameState = 'GAMEOVER';
        beep(100, 'sawtooth', 0.5);
        document.getElementById('final-score').innerText = Math.floor(score);
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    function update() {
        // 1. Energy Decay
        energy -= G.energyDrain;
        if (energy <= 0) gameOver();
        document.getElementById('energy-bar').style.width = Math.max(0, energy) + '%';

        // 2. Player Physics
        if (player.state === 'ORBIT') {
            // Spin
            player.angle += G.rotSpeed * player.dir;
            
            // Lock position to orbit
            const orbitDist = 40;
            player.x = player.targetNode.x + Math.cos(player.angle) * orbitDist;
            player.y = player.targetNode.y + Math.sin(player.angle) * orbitDist;
            
            // Node Instability
            player.targetNode.stability -= G.nodeOverloadRate;
            if (player.targetNode.stability <= 0) gameOver();
            document.getElementById('stability-percent').innerText = Math.max(0, Math.floor(player.targetNode.stability * 100));

        } else if (player.state === 'FLIGHT') {
            player.x += player.vx;
            player.y += player.vy;

            // Check Collisions with unvisited nodes
            let hit = false;
            for (let node of nodes) {
                if (node.connected) continue; // Skip already visited

                const d = Math.hypot(player.x - node.x, player.y - node.y);
                if (d < G.catchRadius) {
                    // --- SUCCESSFUL LINK ---
                    hit = true;
                    
                    // Create Line logic
                    // We need coordinates of where we came FROM. 
                    // Since lines array stores history, the last visited node is nodes[current_index - 1] roughly.
                    // Easier: just store last coordinates when launching? 
                    // Let's use the last connected node in the array.
                    const prevNode = nodes.slice().reverse().find(n => n.connected && n !== node);
                    
                    let distScore = 0;
                    if(prevNode) {
                        lines.push({x1: prevNode.x, y1: prevNode.y, x2: node.x, y2: node.y});
                        distScore = Math.hypot(node.x - prevNode.x, node.y - prevNode.y);
                    }

                    // Score & Energy Logic
                    const energyGain = (distScore / 8); 
                    energy = Math.min(100, energy + energyGain);
                    score += distScore;

                    // UI Updates
                    if (energyGain > 30) showCombo("SURGE +" + Math.floor(energyGain));
                    document.getElementById('current-score').innerText = Math.floor(score);
                    document.getElementById('score-big').innerText = Math.floor(score);

                    // Attach Player
                    node.connected = true;
                    player.targetNode = node;
                    player.state = 'ORBIT';
                    
                    // Calculate smooth entry angle
                    // Angle from node center to player
                    player.angle = Math.atan2(player.y - node.y, player.x - node.x);
                    
                    // Reverse Direction
                    player.dir *= -1;

                    beep(800, 'sine', 0.1);
                    spawnNode();
                    break; 
                }
            }

            // Death if lost in space
            if (!hit) {
                // Find distance to nearest node
                let nearest = 9999;
                nodes.forEach(n => {
                    let d = Math.hypot(player.x - n.x, player.y - n.y);
                    if(d < nearest) nearest = d;
                });
                if(nearest > 600) gameOver();
            }
        }

        // 3. Camera Smooth Follow
        // Target is player, but slightly offset up so we see where we are going
        const targetCamX = player.x - width/2;
        const targetCamY = player.y - height/1.6;
        
        camera.x += (targetCamX - camera.x) * 0.1;
        camera.y += (targetCamY - camera.y) * 0.1;
    }

    function showCombo(text) {
        const el = document.getElementById('combo-alert');
        el.innerText = text; 
        el.style.opacity = 1;
        el.style.transform = "scale(1.2)";
        setTimeout(() => {
            el.style.opacity = 0;
            el.style.transform = "scale(1)";
        }, 1000);
    }

    function draw() {
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(0, 0, width, height);

        // Grid Lines
        ctx.strokeStyle = COLORS.blue;
        ctx.lineWidth = 3;
        ctx.lineCap = 'round';
        ctx.shadowBlur = 10; 
        ctx.shadowColor = COLORS.blue;
        
        lines.forEach(l => {
            ctx.beginPath();
            ctx.moveTo(l.x1 - camera.x, l.y1 - camera.y);
            ctx.lineTo(l.x2 - camera.x, l.y2 - camera.y);
            ctx.stroke();
        });
        ctx.shadowBlur = 0;

        // Nodes
        nodes.forEach(n => n.draw());

        // Player
        if (gameState !== 'GAMEOVER') {
            const px = player.x - camera.x;
            const py = player.y - camera.y;

            // Trail
            if(player.state === 'FLIGHT') {
                ctx.beginPath();
                ctx.moveTo(px - player.vx*4, py - player.vy*4);
                ctx.lineTo(px, py);
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(px, py, 6, 0, Math.PI*2);
            ctx.fillStyle = '#fff'; 
            ctx.fill();
            ctx.shadowBlur = 10; ctx.shadowColor = '#fff';
            ctx.stroke(); ctx.shadowBlur = 0;
        }
    }

    // MAIN LOOP
    function loop() {
        if (gameState === 'PLAYING') {
            update();
            draw();
            requestID = requestAnimationFrame(loop);
        } else if (gameState === 'GAMEOVER') {
            draw(); // Keep drawing static scene
        }
    }

    // Input Listeners
    window.addEventListener('pointerdown', (e) => {
        // Prevent clicking through overlay buttons
        if(e.target.tagName !== 'BUTTON') handleInput(e);
    });
    window.addEventListener('keydown', (e) => {
        if(e.code === 'Space') handleInput(e);
    });

    document.getElementById('start-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        init();
    });
    document.getElementById('restart-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        init();
    });

    // Initial static draw
    resize();
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, width, height);

</script>
</body>
</html>
