<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RB // ENTROPY</title>
    <style>
        /* --- CSS STYLING --- */
        
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&display=swap');

        :root {
            --neon-pink: #FF0055;
            --neon-dim: #990033;
            --text-white: #e0e0e0;
            --bg-black: #050505;
        }

        body {
            margin: 0;
            background-color: var(--bg-black);
            font-family: 'Courier Prime', 'Courier New', monospace;
            color: var(--neon-pink);
            overflow-x: hidden;
        }

        /* The 3D Canvas sits behind everything */
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
            /* Fade out the bottom slightly */
            mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
        }

        /* The Content Overlay */
        main {
            position: relative;
            z-index: 10;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            /* Pushes text below the 3D man visualization */
            padding-top: 65vh; 
            padding-bottom: 50px;
            padding-left: 20px;
            padding-right: 20px;
            box-sizing: border-box;
        }

        /* Typography */
        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px var(--neon-pink);
        }

        .heart {
            color: var(--text-white); 
            font-weight: normal;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--text-white);
            margin-bottom: 2rem;
            letter-spacing: 1px;
            opacity: 0.9;
        }

        .bio-section {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--neon-pink);
        }

        .bio-text {
            color: var(--text-white); 
            border-left: 2px solid var(--neon-pink);
            padding-left: 15px;
        }

        .cursor {
            display: inline-block;
            width: 10px;
            height: 18px;
            background-color: var(--neon-pink);
            animation: blink 1s step-end infinite;
            vertical-align: middle;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            main { padding-top: 55vh; }
            h1 { font-size: 2rem; }
        }
    </style>
</head>
<body>

    <!-- CONTAINER FOR THREE.JS -->
    <div id="canvas-container"></div>

    <!-- UI CONTENT LAYER -->
    <main>
        <!-- Header -->
        <h1><span class="heart">â™¡</span> RB</h1>
        
        <!-- The Quote -->
        <div class="subtitle">
            A Universe of Atoms, An Atom In The Universe
        </div>

        <!-- Bio / Address Block -->
        <div class="bio-section">
            <div style="color: var(--neon-dim); margin-bottom: 5px;">All you need to know about me</div>
            <div class="bio-text">
                > I am RB and I play pixel hockey in my brain<span class="cursor"></span>
            </div>
        </div>
    </main>

    <!-- THREE.JS IMPORT -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- VISUALIZATION SCRIPT -->
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIG ---
        const PARTICLE_COUNT = 40000;
        const COLOR_MAN = new THREE.Color(0xFF0055); // Neon Pink
        const COLOR_HEAT = new THREE.Color(0xFFDD00); // Burning Orange/White
        
        let scene, camera, renderer, controls;
        let particles, geometry, positions, velocities, colors;
        let targetManPositions = [];
        let blackHoleGroup, accretionDisk, lensHalo;
        
        // State Machine
        let state = 'MAN'; 
        let timer = 0;
        
        // Time Steps
        const TIME_MAN = 3.0;
        const TIME_EXPLODE = 1.0;
        const TIME_SUCK = 6.0;
        const TIME_BANG = 0.5;
        const TIME_REFORM = 3.0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.enableZoom = false;

            generateManTargets();
            createParticles();
            createBlackHole();

            window.addEventListener('resize', onWindowResize);
        }

        function createBlackHole() {
            blackHoleGroup = new THREE.Group();
            scene.add(blackHoleGroup);
            blackHoleGroup.visible = false; 

            // Event Horizon
            const sphereGeo = new THREE.SphereGeometry(2, 64, 64);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const sphere = new THREE.Mesh(sphereGeo, sphereMat);
            blackHoleGroup.add(sphere);

            // Accretion Disk (Glow)
            const diskGeo = new THREE.RingGeometry(2.1, 6, 64);
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 1;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0,0,128,0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.1, 'rgba(255, 100, 50, 1)');
            grad.addColorStop(0.5, 'rgba(255, 0, 85, 0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,1);
            const tex = new THREE.CanvasTexture(canvas);
            
            const diskMat = new THREE.MeshBasicMaterial({ 
                map: tex, 
                side: THREE.DoubleSide, 
                transparent: true, 
                blending: THREE.AdditiveBlending,
                depthWrite: false // Helps prevent artifacts
            });
            accretionDisk = new THREE.Mesh(diskGeo, diskMat);
            accretionDisk.rotation.x = Math.PI / 2.3;
            blackHoleGroup.add(accretionDisk);

            // Lensing Halo - FIXED
            const haloGeo = new THREE.PlaneGeometry(15, 15);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0xff0055, 
                transparent: true, 
                opacity: 0.15, 
                blending: THREE.AdditiveBlending,
                depthWrite: false // CRITICAL FIX: Prevents the "square shadow" box effect
            });
            
            const hCanvas = document.createElement('canvas');
            hCanvas.width=64; hCanvas.height=64;
            const hCtx = hCanvas.getContext('2d');
            
            // Reduced outer radius to 28 (from 32) to ensure the glow fades 
            // completely before touching the edge of the square geometry.
            const hGrad = hCtx.createRadialGradient(32,32,10, 32,32,28);
            hGrad.addColorStop(0, 'rgba(0,0,0,0)');
            hGrad.addColorStop(0.5, 'white');
            hGrad.addColorStop(1, 'rgba(0,0,0,0)');
            
            hCtx.fillStyle = hGrad;
            hCtx.fillRect(0,0,64,64);
            
            haloMat.map = new THREE.CanvasTexture(hCanvas);
            haloMat.alphaMap = haloMat.map;
            
            lensHalo = new THREE.Mesh(haloGeo, haloMat);
            blackHoleGroup.add(lensHalo);
        }

        function generateManTargets() {
            const s = 4.0; 
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x=0, y=0, z=0;
                const r = Math.random();

                if (r < 0.15) { // Head
                    const theta = Math.random()*Math.PI*2;
                    const phi = Math.acos(2*Math.random()-1);
                    const rad = 0.4*s;
                    x = rad*Math.sin(phi)*Math.cos(theta);
                    y = rad*Math.sin(phi)*Math.sin(theta) + (1.6*s);
                    z = rad*Math.cos(phi);
                } else if (r < 0.50) { // Torso
                    x = (Math.random()-0.5)*0.9*s;
                    y = (Math.random()*1.0*s) + (0.5*s);
                    z = (Math.random()-0.5)*0.5*s;
                } else if (r < 0.75) { // Legs
                    const leg = Math.random()>0.5?1:-1;
                    x = (leg*0.25*s) + (Math.random()-0.5)*0.3*s;
                    y = Math.random()*0.5*s;
                    z = (Math.random()-0.5)*0.4*s;
                } else { // Arms
                    const arm = Math.random()>0.5?1:-1;
                    x = (arm*0.6*s) + (Math.random()-0.5)*0.25*s;
                    y = (Math.random()*0.8*s) + (0.6*s);
                    z = (Math.random()-0.5)*0.3*s;
                }
                
                // Shift up slightly to fit text below
                y -= 2.0; 
                targetManPositions.push(x, y, z);
            }
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            velocities = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = targetManPositions[i];
                velocities[i] = 0;
                colors[i] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            const material = new THREE.PointsMaterial({
                size: 0.15,
                map: sprite,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updatePhysics(dt) {
            timer += dt;

            // --- STATE CONTROL ---
            if (state === 'MAN') {
                if (timer > TIME_MAN) { state = 'EXPLODE'; timer = 0; }
            } else if (state === 'EXPLODE') {
                if (timer > TIME_EXPLODE) { state = 'SUCK'; timer = 0; blackHoleGroup.visible = true; blackHoleGroup.scale.setScalar(0.1); }
            } else if (state === 'SUCK') {
                if (timer > TIME_SUCK) { state = 'BANG'; timer = 0; }
            } else if (state === 'BANG') {
                if (timer > TIME_BANG) { state = 'REFORM'; timer = 0; blackHoleGroup.visible = false; }
            } else if (state === 'REFORM') {
                if (timer > TIME_REFORM) { state = 'MAN'; timer = 0; }
            }

            // --- PARTICLE PHYSICS ---
            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            const vel = velocities;

            if (state === 'EXPLODE' && timer < dt*2) {
                 for(let i=0; i<PARTICLE_COUNT; i++) {
                     const idx = i*3;
                     const speed = 5 + Math.random()*10;
                     const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                     vel[idx] = dir.x * speed; vel[idx+1] = dir.y * speed; vel[idx+2] = dir.z * speed;
                 }
            }
            if (state === 'BANG' && timer < dt*2) {
                 for(let i=0; i<PARTICLE_COUNT; i++) {
                     const idx = i*3;
                     pos[idx] = (Math.random()-0.5); pos[idx+1] = (Math.random()-0.5); pos[idx+2] = (Math.random()-0.5);
                     const speed = 20 + Math.random()*30;
                     const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                     vel[idx] = dir.x * speed; vel[idx+1] = dir.y * speed; vel[idx+2] = dir.z * speed;
                 }
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i*3;
                let px = pos[idx], py = pos[idx+1], pz = pos[idx+2];
                let vx = vel[idx], vy = vel[idx+1], vz = vel[idx+2];

                if (state === 'MAN') {
                    const tx = targetManPositions[idx];
                    const ty = targetManPositions[idx+1];
                    const tz = targetManPositions[idx+2];
                    
                    px += (tx - px) * 0.1;
                    py += (ty - py) * 0.1;
                    pz += (tz - pz) * 0.1;

                    if(Math.random() < 0.01) px += (Math.random()-0.5);

                    col[idx] = COLOR_MAN.r; col[idx+1] = COLOR_MAN.g; col[idx+2] = COLOR_MAN.b;
                    vx = 0; vy = 0; vz = 0;
                }
                else if (state === 'EXPLODE') {
                    vx *= 0.95; vy *= 0.95; vz *= 0.95;
                }
                else if (state === 'SUCK') {
                    if(blackHoleGroup.scale.x < 1) blackHoleGroup.scale.addScalar(dt*2);
                    
                    const dSq = px*px + py*py + pz*pz;
                    const dist = Math.sqrt(dSq);
                    
                    const G = 250;
                    const f = G / (dSq + 0.1);
                    const inv = 1/(dist+0.01);
                    
                    vx -= px * inv * f * dt;
                    vy -= py * inv * f * dt;
                    vz -= pz * inv * f * dt;

                    const swirl = 10;
                    vx += -pz * swirl * dt;
                    vz += px * swirl * dt;

                    vx *= 0.97; vy *= 0.97; vz *= 0.97;

                    const heat = Math.max(0, 1 - dist/10);
                    col[idx] = THREE.MathUtils.lerp(COLOR_MAN.r, COLOR_HEAT.r, heat);
                    col[idx+1] = THREE.MathUtils.lerp(COLOR_MAN.g, COLOR_HEAT.g, heat);
                    col[idx+2] = THREE.MathUtils.lerp(COLOR_MAN.b, COLOR_HEAT.b, heat);

                    if(dist < 1.5) {
                        px = (Math.random()-0.5)*0.2;
                        py = (Math.random()-0.5)*0.2;
                        pz = (Math.random()-0.5)*0.2;
                        vx=0; vy=0; vz=0; 
                    }
                }
                else if (state === 'BANG') {
                    vx *= 0.98; vy *= 0.98; vz *= 0.98;
                    col[idx] = THREE.MathUtils.lerp(col[idx], COLOR_MAN.r, 0.05);
                    col[idx+1] = THREE.MathUtils.lerp(col[idx+1], COLOR_MAN.g, 0.05);
                    col[idx+2] = THREE.MathUtils.lerp(col[idx+2], COLOR_MAN.b, 0.05);
                }
                else if (state === 'REFORM') {
                    const tx = targetManPositions[idx];
                    const ty = targetManPositions[idx+1];
                    const tz = targetManPositions[idx+2];
                    
                    const lerp = 3.0 * dt;
                    px += (tx - px) * lerp;
                    py += (ty - py) * lerp;
                    pz += (tz - pz) * lerp;
                }

                pos[idx] = px + vx*dt;
                pos[idx+1] = py + vy*dt;
                pos[idx+2] = pz + vz*dt;
                
                vel[idx] = vx; vel[idx+1] = vy; vel[idx+2] = vz;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            if(accretionDisk) accretionDisk.rotation.z -= 0.05;
            if(lensHalo) lensHalo.lookAt(camera.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updatePhysics(0.016);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
