<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>ENTROPY_CYCLE</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <!-- Import Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- CONFIG ---
        const PARTICLE_COUNT = 40000;
        const COLOR_MAN = new THREE.Color(0xFF0055); // Neon Pink
        const COLOR_HEAT = new THREE.Color(0xFFDD00); // Burning Orange/White
        
        let scene, camera, renderer, controls;
        let particles, geometry, positions, velocities, colors;
        let targetManPositions = [];
        let blackHoleGroup, accretionDisk, lensHalo;
        
        // State Machine
        let state = 'MAN'; 
        let timer = 0;
        
        // Time Steps
        const TIME_MAN = 3.0;
        const TIME_EXPLODE = 1.0;
        const TIME_SUCK = 6.0;
        const TIME_BANG = 0.5;
        const TIME_REFORM = 3.0;

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.enableZoom = false;

            // 1. Generate Man Shape
            generateManTargets();

            // 2. Create Particles
            createParticles();

            // 3. Create Black Hole Objects
            createBlackHole();

            window.addEventListener('resize', onWindowResize);
        }

        function createBlackHole() {
            blackHoleGroup = new THREE.Group();
            scene.add(blackHoleGroup);
            blackHoleGroup.visible = false; // Start hidden

            // Event Horizon
            const sphereGeo = new THREE.SphereGeometry(2, 64, 64);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const sphere = new THREE.Mesh(sphereGeo, sphereMat);
            blackHoleGroup.add(sphere);

            // Accretion Disk (Glow)
            const diskGeo = new THREE.RingGeometry(2.1, 6, 64);
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 1;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0,0,128,0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.1, 'rgba(255, 100, 50, 1)');
            grad.addColorStop(0.5, 'rgba(255, 0, 85, 0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,1);
            const tex = new THREE.CanvasTexture(canvas);
            
            const diskMat = new THREE.MeshBasicMaterial({ 
                map: tex, side: THREE.DoubleSide, transparent: true, blending: THREE.AdditiveBlending 
            });
            accretionDisk = new THREE.Mesh(diskGeo, diskMat);
            accretionDisk.rotation.x = Math.PI / 2.3;
            blackHoleGroup.add(accretionDisk);

            // Lensing Halo
            const haloGeo = new THREE.PlaneGeometry(15, 15);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0xff0055, transparent: true, opacity: 0.1, blending: THREE.AdditiveBlending
            });
            const hCanvas = document.createElement('canvas');
            hCanvas.width=64; hCanvas.height=64;
            const hCtx = hCanvas.getContext('2d');
            const hGrad = hCtx.createRadialGradient(32,32,10, 32,32,32);
            hGrad.addColorStop(0, 'rgba(0,0,0,0)');
            hGrad.addColorStop(0.5, 'white');
            hGrad.addColorStop(1, 'rgba(0,0,0,0)');
            hCtx.fillStyle = hGrad;
            hCtx.fillRect(0,0,64,64);
            haloMat.map = new THREE.CanvasTexture(hCanvas);
            haloMat.alphaMap = haloMat.map;
            
            lensHalo = new THREE.Mesh(haloGeo, haloMat);
            blackHoleGroup.add(lensHalo);
        }

        function generateManTargets() {
            // Procedural Human Shape
            const s = 4.0; 
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x=0, y=0, z=0;
                const r = Math.random();

                if (r < 0.15) { // Head
                    const theta = Math.random()*Math.PI*2;
                    const phi = Math.acos(2*Math.random()-1);
                    const rad = 0.4*s;
                    x = rad*Math.sin(phi)*Math.cos(theta);
                    y = rad*Math.sin(phi)*Math.sin(theta) + (1.6*s);
                    z = rad*Math.cos(phi);
                } else if (r < 0.50) { // Torso
                    x = (Math.random()-0.5)*0.9*s;
                    y = (Math.random()*1.0*s) + (0.5*s);
                    z = (Math.random()-0.5)*0.5*s;
                } else if (r < 0.75) { // Legs
                    const leg = Math.random()>0.5?1:-1;
                    x = (leg*0.25*s) + (Math.random()-0.5)*0.3*s;
                    y = Math.random()*0.5*s;
                    z = (Math.random()-0.5)*0.4*s;
                } else { // Arms
                    const arm = Math.random()>0.5?1:-1;
                    x = (arm*0.6*s) + (Math.random()-0.5)*0.25*s;
                    y = (Math.random()*0.8*s) + (0.6*s);
                    z = (Math.random()-0.5)*0.3*s;
                }
                
                // Center vertically
                y -= 3.5;
                targetManPositions.push(x, y, z);
            }
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            velocities = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);

            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = targetManPositions[i];
                velocities[i] = 0;
                colors[i] = 0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            const material = new THREE.PointsMaterial({
                size: 0.15,
                map: sprite,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updatePhysics(dt) {
            timer += dt;

            // --- STATE CONTROL ---
            if (state === 'MAN') {
                if (timer > TIME_MAN) { state = 'EXPLODE'; timer = 0; }
            } else if (state === 'EXPLODE') {
                if (timer > TIME_EXPLODE) { state = 'SUCK'; timer = 0; blackHoleGroup.visible = true; blackHoleGroup.scale.setScalar(0.1); }
            } else if (state === 'SUCK') {
                if (timer > TIME_SUCK) { state = 'BANG'; timer = 0; }
            } else if (state === 'BANG') {
                if (timer > TIME_BANG) { state = 'REFORM'; timer = 0; blackHoleGroup.visible = false; }
            } else if (state === 'REFORM') {
                if (timer > TIME_REFORM) { state = 'MAN'; timer = 0; }
            }

            // --- PARTICLE PHYSICS ---
            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            const vel = velocities;

            // Helper for Explosion/Bang logic to run once
            if (state === 'EXPLODE' && timer < dt*2) {
                 for(let i=0; i<PARTICLE_COUNT; i++) {
                     const idx = i*3;
                     const speed = 5 + Math.random()*10;
                     const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                     vel[idx] = dir.x * speed; vel[idx+1] = dir.y * speed; vel[idx+2] = dir.z * speed;
                 }
            }
            if (state === 'BANG' && timer < dt*2) {
                 for(let i=0; i<PARTICLE_COUNT; i++) {
                     const idx = i*3;
                     pos[idx] = (Math.random()-0.5); pos[idx+1] = (Math.random()-0.5); pos[idx+2] = (Math.random()-0.5);
                     const speed = 20 + Math.random()*30;
                     const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                     vel[idx] = dir.x * speed; vel[idx+1] = dir.y * speed; vel[idx+2] = dir.z * speed;
                 }
            }

            // Loop Particles
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i*3;
                let px = pos[idx], py = pos[idx+1], pz = pos[idx+2];
                let vx = vel[idx], vy = vel[idx+1], vz = vel[idx+2];

                if (state === 'MAN') {
                    // Hologram Glitch
                    const tx = targetManPositions[idx];
                    const ty = targetManPositions[idx+1];
                    const tz = targetManPositions[idx+2];
                    
                    // Snap back
                    px += (tx - px) * 0.1;
                    py += (ty - py) * 0.1;
                    pz += (tz - pz) * 0.1;

                    // Jitter
                    if(Math.random() < 0.01) px += (Math.random()-0.5);

                    // Color Pink
                    col[idx] = COLOR_MAN.r; col[idx+1] = COLOR_MAN.g; col[idx+2] = COLOR_MAN.b;
                    vx = 0; vy = 0; vz = 0;
                }
                else if (state === 'EXPLODE') {
                    // Inertia + Drag
                    vx *= 0.95; vy *= 0.95; vz *= 0.95;
                }
                else if (state === 'SUCK') {
                    // BH Growth
                    if(blackHoleGroup.scale.x < 1) blackHoleGroup.scale.addScalar(dt*2);
                    
                    // Gravity
                    const dSq = px*px + py*py + pz*pz;
                    const dist = Math.sqrt(dSq);
                    
                    // Force
                    const G = 250;
                    const f = G / (dSq + 0.1);
                    const inv = 1/(dist+0.01);
                    
                    vx -= px * inv * f * dt;
                    vy -= py * inv * f * dt;
                    vz -= pz * inv * f * dt;

                    // Swirl
                    const swirl = 10;
                    vx += -pz * swirl * dt;
                    vz += px * swirl * dt;

                    // Friction to ensure capture
                    vx *= 0.97; vy *= 0.97; vz *= 0.97;

                    // Redshift Color (Closer = Hotter)
                    const heat = Math.max(0, 1 - dist/10);
                    col[idx] = THREE.MathUtils.lerp(COLOR_MAN.r, COLOR_HEAT.r, heat);
                    col[idx+1] = THREE.MathUtils.lerp(COLOR_MAN.g, COLOR_HEAT.g, heat);
                    col[idx+2] = THREE.MathUtils.lerp(COLOR_MAN.b, COLOR_HEAT.b, heat);

                    // Event Horizon check
                    if(dist < 1.5) {
                        px = (Math.random()-0.5)*0.2;
                        py = (Math.random()-0.5)*0.2;
                        pz = (Math.random()-0.5)*0.2;
                        vx=0; vy=0; vz=0; 
                    }
                }
                else if (state === 'BANG') {
                    // High velocity outward, color cools down
                    vx *= 0.98; vy *= 0.98; vz *= 0.98;
                    col[idx] = THREE.MathUtils.lerp(col[idx], COLOR_MAN.r, 0.05);
                    col[idx+1] = THREE.MathUtils.lerp(col[idx+1], COLOR_MAN.g, 0.05);
                    col[idx+2] = THREE.MathUtils.lerp(col[idx+2], COLOR_MAN.b, 0.05);
                }
                else if (state === 'REFORM') {
                    const tx = targetManPositions[idx];
                    const ty = targetManPositions[idx+1];
                    const tz = targetManPositions[idx+2];
                    
                    const lerp = 3.0 * dt;
                    px += (tx - px) * lerp;
                    py += (ty - py) * lerp;
                    pz += (tz - pz) * lerp;
                }

                pos[idx] = px + vx*dt;
                pos[idx+1] = py + vy*dt;
                pos[idx+2] = pz + vz*dt;
                
                vel[idx] = vx; vel[idx+1] = vy; vel[idx+2] = vz;
            }

            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;

            // Visual Updates
            if(accretionDisk) accretionDisk.rotation.z -= 0.05;
            if(lensHalo) lensHalo.lookAt(camera.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updatePhysics(0.016);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
