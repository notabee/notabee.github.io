<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RB // ENTROPY (Soft Audio)</title>
    <style>
        /* --- CSS STYLING --- */
        
        @import url('https://fonts.googleapis.com/css2?family=Courier+Prime:ital,wght@0,400;0,700;1,400&display=swap');

        :root {
            --neon-pink: #FF0055;
            --neon-dim: #990033;
            --text-white: #e0e0e0;
            --bg-black: #050505;
        }

        body {
            margin: 0;
            background-color: var(--bg-black);
            font-family: 'Courier Prime', 'Courier New', monospace;
            color: var(--neon-pink);
            overflow: hidden;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            z-index: -1;
            mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
        }

        main {
            position: relative;
            z-index: 10;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            padding-top: 65vh; 
            padding-bottom: 50px;
            padding-left: 20px;
            padding-right: 20px;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 2s ease;
            pointer-events: none;
        }

        main.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* START OVERLAY */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.95);
            z-index: 999;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: opacity 0.5s;
        }

        #start-btn {
            border: 1px solid var(--neon-pink);
            color: var(--neon-pink);
            padding: 15px 30px;
            font-family: inherit;
            font-size: 1.2rem;
            background: transparent;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: pulse 2s infinite;
        }
        
        #start-sub {
            margin-top: 15px;
            color: var(--text-white);
            font-size: 0.8rem;
            opacity: 0.7;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            text-shadow: 0 0 10px var(--neon-pink);
        }

        .heart { color: var(--text-white); font-weight: normal; }
        .subtitle { font-size: 1.1rem; color: var(--text-white); margin-bottom: 2rem; letter-spacing: 1px; opacity: 0.9; }
        .bio-section { font-size: 1rem; line-height: 1.6; color: var(--neon-pink); }
        .bio-text { color: var(--text-white); border-left: 2px solid var(--neon-pink); padding-left: 15px; }
        .cursor { display: inline-block; width: 10px; height: 18px; background-color: var(--neon-pink); animation: blink 1s step-end infinite; vertical-align: middle; }

        @keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(255, 0, 85, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 0, 85, 0); } }
        @media (max-width: 600px) { main { padding-top: 55vh; } h1 { font-size: 2rem; } }
    </style>
</head>
<body>

    <div id="start-overlay">
        <div id="start-btn">Initialize System</div>
        <div id="start-sub">[ Audio + Visual Experience ]</div>
    </div>

    <div id="canvas-container"></div>

    <main id="main-content">
        <h1><span class="heart">â™¡</span> RB</h1>
        <div class="subtitle">A Universe of Atoms, An Atom In The Universe</div>
        <div class="bio-section">
            <div style="color: var(--neon-dim); margin-bottom: 5px;">All you need to know about me</div>
            <div class="bio-text">
                > I am RB and I play pixel hockey in my brain<span class="cursor"></span>
            </div>
        </div>
    </main>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- AUDIO ENGINE CLASS ---
        class SynthEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.isSetup = false;
                this.droneOscs = [];
                this.suckOsc = null;
                this.suckGain = null;
            }

            setup() {
                if (this.isSetup) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-24, this.ctx.currentTime);
                compressor.knee.setValueAtTime(30, this.ctx.currentTime);
                compressor.ratio.setValueAtTime(12, this.ctx.currentTime);
                compressor.attack.setValueAtTime(0.003, this.ctx.currentTime);
                compressor.release.setValueAtTime(0.25, this.ctx.currentTime);
                compressor.connect(this.ctx.destination);

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5; 
                this.masterGain.connect(compressor);
                this.isSetup = true;
            }

            resume() { if(this.ctx && this.ctx.state === 'suspended') this.ctx.resume(); }

            // 1. MAN STATE: Drone
            startDrone() {
                if (!this.isSetup) return;
                this.stopDrone();
                const freqs = [110, 112];
                freqs.forEach(f => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = f;
                    gain.gain.value = 0;
                    gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 2);
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start();
                    this.droneOscs.push({osc, gain});
                });
            }

            stopDrone() {
                this.droneOscs.forEach(o => {
                    o.gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
                    o.osc.stop(this.ctx.currentTime + 1);
                });
                this.droneOscs = [];
            }

            triggerHeartbeat() {
                if (!this.isSetup) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.2);
            }

            // --- DEEP BOOM EXPLOSION ---
            triggerDeepBoom() {
                if (!this.isSetup) return;
                const t = this.ctx.currentTime;

                // LAYER 1: Sub-Bass Drop
                const subOsc = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                subOsc.type = 'triangle';
                subOsc.frequency.setValueAtTime(80, t);
                subOsc.frequency.exponentialRampToValueAtTime(10, t + 1.0);
                
                subGain.gain.setValueAtTime(1.0, t);
                subGain.gain.exponentialRampToValueAtTime(0.001, t + 1.5);
                
                subOsc.connect(subGain);
                subGain.connect(this.masterGain);
                subOsc.start(t);
                subOsc.stop(t + 2.0);

                // LAYER 2: Filtered Rumble
                const bufferSize = this.ctx.sampleRate * 3.0;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1);

                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;

                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(600, t); 
                noiseFilter.frequency.exponentialRampToValueAtTime(30, t + 2.0);

                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(1.2, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 2.5);

                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                noise.start(t);
            }

            triggerExplosion() {
                if (!this.isSetup) return;
                this.stopDrone();
                this.triggerDeepBoom();
            }

            // 3. SUCK STATE (MODIFIED: Softer Sine Wave)
            startSuck() {
                if (!this.isSetup) return;
                
                this.suckOsc = this.ctx.createOscillator();
                this.suckGain = this.ctx.createGain();
                
                // CHANGED: From 'sawtooth' (harsh) to 'sine' (smooth)
                this.suckOsc.type = 'sine';
                
                // CHANGED: Start frequency slightly higher (60Hz)
                this.suckOsc.frequency.setValueAtTime(60, this.ctx.currentTime);
                
                // CHANGED: End frequency much lower (300Hz instead of 800Hz)
                // This prevents the "hurt ears" high pitch
                this.suckOsc.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 6);
                
                this.suckGain.gain.value = 0;
                this.suckGain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 5);

                this.suckOsc.connect(this.suckGain);
                this.suckGain.connect(this.masterGain);
                this.suckOsc.start();
            }

            // MODIFIED: Softer Clicks
            triggerGeigerTick(intensity) {
                if (!this.isSetup) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                // CHANGED: From 'square' to 'triangle' (softer)
                osc.type = 'triangle'; 
                
                // CHANGED: Lower pitch (200-400Hz instead of 800-1200Hz)
                osc.frequency.value = 200 + (Math.random()*200);
                
                gain.gain.setValueAtTime(0.15 * intensity, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.05);
            }

            stopSuck() {
                if(this.suckOsc) {
                    this.suckOsc.stop();
                    this.suckOsc = null;
                }
            }

            triggerBang() {
                this.stopSuck();
                this.triggerDeepBoom();
            }

            // 5. REFORM
            triggerReformBlip() {
                if (!this.isSetup) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const notes = [440, 523.25, 587.33, 659.25, 783.99, 880];
                const freq = notes[Math.floor(Math.random()*notes.length)];
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                const panner = this.ctx.createStereoPanner();
                panner.pan.value = (Math.random()*2) - 1;
                osc.connect(gain);
                gain.connect(panner);
                panner.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }
        }

        const synth = new SynthEngine();

        // --- THREE.JS LOGIC ---
        const PARTICLE_COUNT = 40000;
        const COLOR_MAN = new THREE.Color(0xFF0055); 
        const COLOR_HEAT = new THREE.Color(0xFFDD00); 
        
        let scene, camera, renderer, controls;
        let particles, geometry, positions, velocities, colors;
        let targetManPositions = [];
        let blackHoleGroup, accretionDisk, lensHalo;
        
        let state = 'MAN'; 
        let lastState = '';
        let timer = 0;
        
        const TIME_MAN = 4.0;
        const TIME_EXPLODE = 1.0;
        const TIME_SUCK = 6.0;
        const TIME_BANG = 0.5;
        const TIME_REFORM = 3.0;

        let beatTimer = 0;

        init();

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 4.0; 
            controls.enableZoom = false;

            generateManTargets();
            createParticles();
            createBlackHole();

            const overlay = document.getElementById('start-overlay');
            const mainContent = document.getElementById('main-content');
            
            overlay.addEventListener('click', () => {
                synth.setup();
                synth.resume();
                synth.startDrone();
                overlay.style.opacity = 0;
                setTimeout(() => {
                    overlay.style.display = 'none';
                    mainContent.classList.add('visible');
                    animate();
                }, 500);
            });

            window.addEventListener('resize', onWindowResize);
        }

        function createBlackHole() {
            blackHoleGroup = new THREE.Group();
            scene.add(blackHoleGroup);
            blackHoleGroup.visible = false; 

            const sphereGeo = new THREE.SphereGeometry(2, 64, 64);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            blackHoleGroup.add(new THREE.Mesh(sphereGeo, sphereMat));

            const diskGeo = new THREE.RingGeometry(2.1, 6, 64);
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 1;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createLinearGradient(0,0,128,0);
            grad.addColorStop(0, 'rgba(0,0,0,0)');
            grad.addColorStop(0.1, 'rgba(255, 100, 50, 1)');
            grad.addColorStop(0.5, 'rgba(255, 0, 85, 0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,1);
            const tex = new THREE.CanvasTexture(canvas);
            
            const diskMat = new THREE.MeshBasicMaterial({ 
                map: tex, side: THREE.DoubleSide, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false 
            });
            accretionDisk = new THREE.Mesh(diskGeo, diskMat);
            accretionDisk.rotation.x = Math.PI / 2.3;
            blackHoleGroup.add(accretionDisk);

            const haloGeo = new THREE.PlaneGeometry(15, 15);
            const haloMat = new THREE.MeshBasicMaterial({
                color: 0xff0055, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, depthWrite: false
            });
            const hCanvas = document.createElement('canvas');
            hCanvas.width=64; hCanvas.height=64;
            const hCtx = hCanvas.getContext('2d');
            const hGrad = hCtx.createRadialGradient(32,32,10, 32,32,28);
            hGrad.addColorStop(0, 'rgba(0,0,0,0)');
            hGrad.addColorStop(0.5, 'white');
            hGrad.addColorStop(1, 'rgba(0,0,0,0)');
            hCtx.fillStyle = hGrad;
            hCtx.fillRect(0,0,64,64);
            haloMat.map = new THREE.CanvasTexture(hCanvas);
            haloMat.alphaMap = haloMat.map;
            lensHalo = new THREE.Mesh(haloGeo, haloMat);
            blackHoleGroup.add(lensHalo);
        }

        function generateManTargets() {
            const s = 4.0; 
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x=0, y=0, z=0;
                const r = Math.random();
                if (r < 0.15) { 
                    const theta = Math.random()*Math.PI*2; const phi = Math.acos(2*Math.random()-1); const rad = 0.4*s;
                    x = rad*Math.sin(phi)*Math.cos(theta); y = rad*Math.sin(phi)*Math.sin(theta) + (1.6*s); z = rad*Math.cos(phi);
                } else if (r < 0.50) { 
                    x = (Math.random()-0.5)*0.9*s; y = (Math.random()*1.0*s) + (0.5*s); z = (Math.random()-0.5)*0.5*s;
                } else if (r < 0.75) { 
                    const leg = Math.random()>0.5?1:-1; x = (leg*0.25*s) + (Math.random()-0.5)*0.3*s; y = Math.random()*0.5*s; z = (Math.random()-0.5)*0.4*s;
                } else { 
                    const arm = Math.random()>0.5?1:-1; x = (arm*0.6*s) + (Math.random()-0.5)*0.25*s; y = (Math.random()*0.8*s) + (0.6*s); z = (Math.random()-0.5)*0.3*s;
                }
                y -= 2.0; 
                targetManPositions.push(x, y, z);
            }
        }

        function createParticles() {
            geometry = new THREE.BufferGeometry();
            positions = new Float32Array(PARTICLE_COUNT * 3);
            velocities = new Float32Array(PARTICLE_COUNT * 3);
            colors = new Float32Array(PARTICLE_COUNT * 3);
            for (let i = 0; i < PARTICLE_COUNT * 3; i++) {
                positions[i] = targetManPositions[i]; velocities[i] = 0; colors[i] = 0;
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
            const material = new THREE.PointsMaterial({
                size: 0.15, map: sprite, vertexColors: true, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending, depthWrite: false
            });
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updatePhysics(dt) {
            timer += dt;

            if (state === 'MAN') {
                if (timer > TIME_MAN) { state = 'EXPLODE'; timer = 0; }
                beatTimer += dt;
                if(beatTimer > 1.2) { synth.triggerHeartbeat(); beatTimer = 0; }
            } 
            else if (state === 'EXPLODE') {
                if (timer > TIME_EXPLODE) { state = 'SUCK'; timer = 0; blackHoleGroup.visible = true; blackHoleGroup.scale.setScalar(0.1); }
            } 
            else if (state === 'SUCK') {
                if (timer > TIME_SUCK) { state = 'BANG'; timer = 0; }
                beatTimer += dt;
                const interval = Math.max(0.05, 0.5 - (timer/TIME_SUCK)*0.45); 
                if(beatTimer > interval) { synth.triggerGeigerTick(timer/TIME_SUCK); beatTimer = 0; }
            } 
            else if (state === 'BANG') {
                if (timer > TIME_BANG) { state = 'REFORM'; timer = 0; blackHoleGroup.visible = false; }
            } 
            else if (state === 'REFORM') {
                if (timer > TIME_REFORM) { state = 'MAN'; timer = 0; }
                if(Math.random() < 0.1) synth.triggerReformBlip();
            }

            // AUDIO SYNC
            if(state !== lastState) {
                if(state === 'MAN') synth.startDrone();
                if(state === 'EXPLODE') synth.triggerExplosion();
                if(state === 'SUCK') synth.startSuck();
                if(state === 'BANG') synth.triggerBang();
                lastState = state;
            }

            const pos = geometry.attributes.position.array;
            const col = geometry.attributes.color.array;
            const vel = velocities;

            if (state === 'EXPLODE' && timer < dt*2) {
                 for(let i=0; i<PARTICLE_COUNT; i++) {
                     const idx = i*3;
                     const speed = 5 + Math.random()*10;
                     const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                     vel[idx] = dir.x * speed; vel[idx+1] = dir.y * speed; vel[idx+2] = dir.z * speed;
                 }
            }
            if (state === 'BANG' && timer < dt*2) {
                 for(let i=0; i<PARTICLE_COUNT; i++) {
                     const idx = i*3;
                     pos[idx] = (Math.random()-0.5); pos[idx+1] = (Math.random()-0.5); pos[idx+2] = (Math.random()-0.5);
                     const speed = 20 + Math.random()*30;
                     const dir = new THREE.Vector3(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5).normalize();
                     vel[idx] = dir.x * speed; vel[idx+1] = dir.y * speed; vel[idx+2] = dir.z * speed;
                 }
            }

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const idx = i*3;
                let px = pos[idx], py = pos[idx+1], pz = pos[idx+2];
                let vx = vel[idx], vy = vel[idx+1], vz = vel[idx+2];

                if (state === 'MAN') {
                    const tx = targetManPositions[idx]; const ty = targetManPositions[idx+1]; const tz = targetManPositions[idx+2];
                    px += (tx - px) * 0.1; py += (ty - py) * 0.1; pz += (tz - pz) * 0.1;
                    if(Math.random() < 0.01) px += (Math.random()-0.5); 
                    const pulse = Math.sin(beatTimer * 5) > 0 ? 1.2 : 1.0;
                    col[idx] = COLOR_MAN.r * pulse; col[idx+1] = COLOR_MAN.g * pulse; col[idx+2] = COLOR_MAN.b * pulse;
                    vx = 0; vy = 0; vz = 0;
                }
                else if (state === 'EXPLODE') {
                    vx *= 0.95; vy *= 0.95; vz *= 0.95;
                }
                else if (state === 'SUCK') {
                    if(blackHoleGroup.scale.x < 1) blackHoleGroup.scale.addScalar(dt*2);
                    const dSq = px*px + py*py + pz*pz; const dist = Math.sqrt(dSq);
                    const G = 250; const f = G / (dSq + 0.1); const inv = 1/(dist+0.01);
                    vx -= px * inv * f * dt; vy -= py * inv * f * dt; vz -= pz * inv * f * dt;
                    const swirl = 10; vx += -pz * swirl * dt; vz += px * swirl * dt;
                    vx *= 0.97; vy *= 0.97; vz *= 0.97;
                    const heat = Math.max(0, 1 - dist/10);
                    col[idx] = THREE.MathUtils.lerp(COLOR_MAN.r, COLOR_HEAT.r, heat); col[idx+1] = THREE.MathUtils.lerp(COLOR_MAN.g, COLOR_HEAT.g, heat); col[idx+2] = THREE.MathUtils.lerp(COLOR_MAN.b, COLOR_HEAT.b, heat);
                    if(dist < 1.5) { px = (Math.random()-0.5)*0.2; py = (Math.random()-0.5)*0.2; pz = (Math.random()-0.5)*0.2; vx=0; vy=0; vz=0; }
                }
                else if (state === 'BANG') {
                    vx *= 0.98; vy *= 0.98; vz *= 0.98;
                    col[idx] = THREE.MathUtils.lerp(col[idx], COLOR_MAN.r, 0.05); col[idx+1] = THREE.MathUtils.lerp(col[idx+1], COLOR_MAN.g, 0.05); col[idx+2] = THREE.MathUtils.lerp(col[idx+2], COLOR_MAN.b, 0.05);
                }
                else if (state === 'REFORM') {
                    const tx = targetManPositions[idx]; const ty = targetManPositions[idx+1]; const tz = targetManPositions[idx+2];
                    const lerp = 3.0 * dt; px += (tx - px) * lerp; py += (ty - py) * lerp; pz += (tz - pz) * lerp;
                }
                pos[idx] = px + vx*dt; pos[idx+1] = py + vy*dt; pos[idx+2] = pz + vz*dt;
                vel[idx] = vx; vel[idx+1] = vy; vel[idx+2] = vz;
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.color.needsUpdate = true;
            if(accretionDisk) accretionDisk.rotation.z -= 0.05;
            if(lensHalo) lensHalo.lookAt(camera.position);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            updatePhysics(0.016);
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
